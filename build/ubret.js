// Generated by CoffeeScript 1.3.3
(function() {
  var Ubret;

  if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
    Ubret = {
      Map: require('./ubret/map'),
      Statistics: require('./ubret/statistics'),
      SubjectViewer: require('./ubret/subject_viewer'),
      Table: require('./ubret/table')
    };
    module.exports = Ubret;
  } else {
    window.Ubret = {};
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var BaseTool,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  BaseTool = (function() {

    BaseTool.prototype.required_opts = ['data', 'selector', 'el', 'keys'];

    function BaseTool(opts) {
      this.addFilter = __bind(this.addFilter, this);

      this.createDimensions = __bind(this.createDimensions, this);

      this.selectKey = __bind(this.selectKey, this);

      this.selectElements = __bind(this.selectElements, this);

      this.uglifyKey = __bind(this.uglifyKey, this);

      this.prettyKey = __bind(this.prettyKey, this);

      this.getTemplate = __bind(this.getTemplate, this);

      var filter, opt, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.required_opts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        opt = _ref[_i];
        if (!_.has(opts, opt)) {
          throw "missing option " + opt;
        }
      }
      this.data = crossfilter(opts.data);
      this.selector = opts.selector;
      this.keys = opts.keys;
      this.el = opts.el;
      this.selectElementCb = opts.selectElementCb || function() {};
      this.selectKeyCb = opts.selectKeyCb || function() {};
      this.selectedElement = opts.selectedElement || null;
      this.selectedKey = opts.selectedKey || 'id';
      this.createDimensions();
      _ref1 = opts.filters;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        filter = _ref1[_j];
        this.addFilter(filter);
      }
    }

    BaseTool.prototype.getTemplate = function() {
      return this.template;
    };

    BaseTool.prototype.prettyKey = function(key) {
      return this.capitalizeWords(this.underscoresToSpaces(key));
    };

    BaseTool.prototype.uglifyKey = function(key) {
      return this.spacesToUnderscores(this.lowercaseWords(key));
    };

    BaseTool.prototype.selectElements = function(ids) {
      this.selectedElements = ids;
      this.selectElementsCb(ids);
      return this.start();
    };

    BaseTool.prototype.selectKey = function(key) {
      this.selectedKey = key;
      this.selectKeyCb(key);
      return this.start();
    };

    BaseTool.prototype.createDimensions = function() {
      var key, _i, _len, _ref, _results;
      this.dimensions = new Object;
      _ref = this.keys;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        this.dimensions.id = this.data.dimension(function(d) {
          return d.id;
        });
        _results.push(this.dimensions[key] = this.data.dimension(function(d) {
          return d[key];
        }));
      }
      return _results;
    };

    BaseTool.prototype.addFilter = function(filter) {
      return this.dimensions[filter.key].filterRange([filter.low, filter.hight]);
    };

    BaseTool.prototype.formatKey = function(key) {
      return (key.replace(/_/g, " ")).replace(/(\b[a-z])/g, function(char) {
        return char.toUpperCase();
      });
    };

    return BaseTool;

  })();

  if (typeof require === 'function' && typeof module === 'object' && typeof exports === 'object') {
    module.exports = BaseTool;
  } else {
    window.Ubret['BaseTool'] = BaseTool;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var BaseTool, Graph,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseTool = window.Ubret.BaseTool || require('./base_tool');

  Graph = (function(_super) {

    __extends(Graph, _super);

    function Graph(opts) {
      this.createYAxis = __bind(this.createYAxis, this);

      this.createXAxis = __bind(this.createXAxis, this);

      this.createGraph = __bind(this.createGraph, this);

      var compiled;
      console.log('Graph');
      Graph.__super__.constructor.call(this, opts);
      compiled = _.template(this.template, {
        selector: this.selector
      });
      this.el.html(compiled);
      this.height = opts.width || this.el.height();
      this.width = opts.height || this.el.width();
      this.margin = opts.margin || {
        left: 60,
        top: 20,
        bottom: 60,
        right: 40
      };
      this.format = opts.format ? d3.format(opts.format) : d3.format(',.02f');
      this.color = opts.color || '#0172E6';
      this.selectionColor = opts.selectionColor || '#CD3E20';
    }

    Graph.prototype.createGraph = function() {
      var graphHeight, graphWidth;
      graphHeight = this.height - (this.margin.top + this.margin.bottom);
      graphWidth = this.width - (this.margin.left + this.margin.right);
      return this.svg = d3.select(this.selector).append('svg').attr('height', graphHeight).attr('width', graphWidth);
    };

    Graph.prototype.createXAxis = function(dataSet, ticks) {
      var xAxis, xDomain;
      xDomain = d3.extent(dataSet, d(function() {
        return d.x;
      }));
      if (xDomain.length === 0) {
        xDomain = [0, 1];
      }
      this.x = d3.scale.linear().domain(xDomain).range([0, this.graphWidth]);
      return xAxis = d3.svg.axis().scale(this.x).orient('bottom');
    };

    Graph.prototype.createYAxis = function(dataSet, ticks) {
      var yDomain;
      yDomain = d3.extent(dataSet, d(function() {
        return d.y;
      }));
      if (yDomain.length === 0) {
        yDomain = [0, 1];
      }
      return this.y = d3.scale.linear().domain(yDomain).range(0);
    };

    return Graph;

  })(BaseTool);

  if (typeof require === 'function' && typeof module === 'object' && typeof exports === 'object') {
    module.exports = Graph;
  } else {
    window.Ubret.Graph = Graph;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var BaseTool, Histogram,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  BaseTool = window.Ubret.BaseTool || require('./base_tool');

  Histogram = (function(_super) {

    __extends(Histogram, _super);

    Histogram.prototype.template = "<div class=\"histogram\">\n  <div id=\"<%- selector %>\">\n    <svg></svg>\n  </div>\n</div>";

    function Histogram(opts) {
      this.start = __bind(this.start, this);

      this.setXVar = __bind(this.setXVar, this);

      this.drawBars = __bind(this.drawBars, this);

      this.createGraph = __bind(this.createGraph, this);

      var compiled;
      Histogram.__super__.constructor.call(this, opts);
      compiled = _.template(this.template, {
        selector: this.selector
      });
      this.el.html(compiled);
      this.height = opts.height || 480;
      this.width = opts.width || 640;
      this.margin = opts.margin || {
        left: 60,
        top: 20,
        bottom: 60,
        right: 40
      };
      this.format = opts.format ? d3.format(opts.format) : d3.format('.3f');
      this.color = opts.color || '#0172E6';
      this.selectionColor = opts.selectionColor || '#CD3E20';
      this.yLabel = opts.yLabel || 'Count';
      this.createGraph();
    }

    Histogram.prototype.createGraph = function() {
      var bin, binFunction, binRanges, bins, data, lastBin, lastTick, selectedBin, selectedData, ticks, unselectedBin, unselectedData, xAxis, xDomain, yAxis, yDomain, _i, _len,
        _this = this;
      this.selectedData = [];
      if (typeof this.selectedKey === 'undefined') {
        return;
      }
      this.el.find('svg').empty();
      this.graphWidth = this.width - this.margin.left - this.margin.right;
      this.graphHeight = this.height - this.margin.top - this.margin.bottom;
      this.formatCount = d3.format(',.0f');
      this.svg = d3.select("" + this.selector + " svg").attr('width', this.width).attr('height', this.height).append('g').attr('transform', "translate(" + this.margin.left + ", " + this.margin.top + ")");
      if (this.data.length > 1) {
        data = _.map(this.data, function(d) {
          return d[_this.selectedKey];
        });
        data = _.filter(data, function(d) {
          return d !== null;
        });
        if (this.binNumber != null) {
          bins = d3.layout.histogram().bins(this.binNumber)(data);
        } else {
          bins = d3.layout.histogram()(data);
        }
        xDomain = d3.extent(this.data, function(d) {
          return parseFloat(d[_this.selectedKey]);
        });
        yDomain = [
          0, d3.max(bins, function(d) {
            return d.y;
          })
        ];
      } else if (this.data.length === 1) {
        svg.append('text').attr('class', 'data-warning').attr('y', graphHeight / 2).attr('x', graphWidth / 2).attr('text-anchor', 'middle').text('Not Enough Data, Classify More Galaxies!');
        return;
      } else {
        bins = [];
        xDomain = [0, 1];
        yDomain = [0, 1];
      }
      if (this.selectedData.length !== 0) {
        binRanges = _.map(bins, function(d) {
          return d.x;
        });
        binFunction = d3.layout.histogram().bins(binRanges);
        unselectedData = _.filter(this.filteredData, function(d) {
          return !(__indexOf.call(_this.selectedData, d) >= 0);
        });
        selectedData = _.map(this.selectedData, function(d) {
          return d[_this.selectedKey];
        });
        unselectedData = _.map(unselectedData, function(d) {
          return d[_this.selectedKey];
        });
        unselectedBin = binFunction(unselectedData);
        selectedBin = binFunction(selectedData);
        yDomain = [
          0, d3.max([
            d3.max(unselectedBin, function(d) {
              return d.y;
            }), d3.max(selectedBin, function(d) {
              return d.y;
            })
          ])
        ];
      }
      this.x = d3.scale.linear().domain(xDomain).range([0, this.graphWidth]);
      this.y = d3.scale.linear().domain(yDomain).range([this.graphHeight, 0]);
      xAxis = d3.svg.axis().scale(this.x).orient('bottom');
      if (bins.length !== 0) {
        ticks = new Array;
        for (_i = 0, _len = bins.length; _i < _len; _i++) {
          bin = bins[_i];
          ticks.push(bin.x);
        }
        lastBin = _.last(bins);
        lastTick = lastBin.x + lastBin.dx;
        ticks.push(lastTick);
      } else {
        ticks = [0, 0.25, 0.5, 0.75, 1];
      }
      xAxis.tickValues(ticks);
      xAxis.tickFormat(this.format);
      yAxis = d3.svg.axis().scale(this.y).orient('left').tickFormat(function(tick) {
        if (Math.floor(tick) !== tick) {
          return;
        }
        return tick;
      });
      this.svg.append('g').attr('class', 'x axis').attr('transform', "translate(0, " + this.graphHeight + ")").call(xAxis);
      this.svg.append('g').attr('class', 'y axis').attr('transform', "translate(0, 0)").call(yAxis);
      this.svg.append('text').attr('class', 'x label').attr('text-anchor', 'middle').attr('x', this.graphWidth / 2).attr('y', this.graphHeight + 35).text(this.prettyKey(this.selectedKey));
      this.svg.append('text').attr('class', 'y label').attr('text-anchor', 'middle').attr('y', -40).attr('x', -(this.graphHeight / 2)).attr('transform', "rotate(-90)").text(this.yLabel);
      if (bins.length !== 0) {
        if (this.selectedData.length !== 0) {
          if (unselectedData.length > 1) {
            this.drawBars(unselectedBin, this.color, true);
          }
          if (selectedData.length > 1) {
            return this.drawBars(selectedBin, this.selectionColor, true, true);
          }
        } else {
          return this.drawBars(bins, this.color);
        }
      }
    };

    Histogram.prototype.drawBars = function(bins, color, halfSize, offset) {
      var bar, width, witth,
        _this = this;
      if (halfSize == null) {
        halfSize = false;
      }
      if (offset == null) {
        offset = false;
      }
      width = this.x(bins[1].x) - this.x(bins[0].x);
      width = halfSize ? (width / 2) - 1 : width - 2;
      witth = offset ? width - 1 : width;
      bar = this.svg.selectAll(".bar-" + color).data(bins).enter().append('g').attr('class', 'bar').attr('transform', function(d) {
        if (offset) {
          return "translate(" + (_this.x(d.x) + width + 1) + ", " + (_this.y(d.y) - 1) + ")";
        } else {
          return "translate(" + (_this.x(d.x)) + ", " + (_this.y(d.y) - 1) + ")";
        }
      });
      bar.append('rect').attr('x', 1).attr('width', Math.floor(width)).attr('height', function(d) {
        return _this.graphHeight - _this.y(d.y);
      }).attr('fill', color);
      return bar.append('text').attr("dy", ".75em").attr("y", 6).attr("x", width / 2).attr("text-anchor", "middle").text(function(d) {
        return _this.formatCount(d.y);
      });
    };

    Histogram.prototype.setXVar = function(variable) {
      this.selectedKey = variable;
      return this.createGraph();
    };

    Histogram.prototype.start = function() {
      return this.createGraph();
    };

    return Histogram;

  })(BaseTool);

  if (typeof require === 'function' && typeof module === 'object' && typeof exports === 'object') {
    module.exports = Histogram;
  } else {
    window.Ubret['Histogram'] = Histogram;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var Graph, Histogram2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Graph = window.Ubret.Graph || require('./Graph');

  Histogram2 = (function(_super) {

    __extends(Histogram2, _super);

    Histogram2.prototype.axes = 1;

    Histogram2.prototype.template = "<div class=\"histogram\">\n  <div id=\"<%- selector %>\">\n    <svg></svg>\n  </div>\n</div>";

    function Histogram2(opts) {
      this.start = __bind(this.start, this);

      this.setXVar = __bind(this.setXVar, this);

      this.drawBars = __bind(this.drawBars, this);
      console.log('Histogram2');
      Histogram2.__super__.constructor.call(this, opts);
      this.yLabel = opts.yLabel || 'Count';
    }

    Histogram2.prototype.drawBars = function(bins, color, halfSize, offset) {
      var bar, width, witth,
        _this = this;
      if (halfSize == null) {
        halfSize = false;
      }
      if (offset == null) {
        offset = false;
      }
      width = this.x(bins[1].x) - this.x(bins[0].x);
      width = halfSize ? (width / 2) - 1 : width - 2;
      witth = offset ? width - 1 : width;
      bar = this.svg.selectAll(".bar-" + color).data(bins).enter().append('g').attr('class', 'bar').attr('transform', function(d) {
        if (offset) {
          return "translate(" + (_this.x(d.x) + width + 1) + ", " + (_this.y(d.y) - 1) + ")";
        } else {
          return "translate(" + (_this.x(d.x)) + ", " + (_this.y(d.y) - 1) + ")";
        }
      });
      bar.append('rect').attr('x', 1).attr('width', Math.floor(width)).attr('height', function(d) {
        return _this.graphHeight - _this.y(d.y);
      }).attr('fill', color);
      return bar.append('text').attr("dy", ".75em").attr("y", 6).attr("x", width / 2).attr("text-anchor", "middle").text(function(d) {
        return _this.formatCount(d.y);
      });
    };

    Histogram2.prototype.setXVar = function(variable) {
      this.selectedKey = variable;
      return this.createGraph();
    };

    Histogram2.prototype.start = function() {
      return this.createGraph();
    };

    return Histogram2;

  })(Graph);

  if (typeof require === 'function' && typeof module === 'object' && typeof exports === 'object') {
    module.exports = Histogram2;
  } else {
    window.Ubret['Histogram2'] = Histogram2;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var BaseTool, Map,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseTool = window.Ubret.BaseTool || require('./base_tool');

  Map = (function(_super) {

    __extends(Map, _super);

    Map.prototype.template = "<div id=\"<%- selector %>\"></div>";

    Map.mapOptions = {
      attributionControl: false
    };

    L.Icon.Default.imagePath = 'css/images';

    Map.prototype.default_icon = new L.icon({
      className: 'default_icon',
      iconUrl: '/css/images/marker-icon.png',
      iconSize: [25, 41],
      iconAnchor: [13, 41]
    });

    Map.prototype.selected_icon = new L.icon({
      className: 'selected_icon',
      iconUrl: '/css/images/marker-icon-orange.png',
      iconSize: [25, 41],
      iconAnchor: [13, 41]
    });

    function Map() {
      this.selectSubject = __bind(this.selectSubject, this);

      this.selected = __bind(this.selected, this);

      this.plotObjects = __bind(this.plotObjects, this);

      this.plotObject = __bind(this.plotObject, this);

      this.createSky = __bind(this.createSky, this);

      this.start = __bind(this.start, this);

      this.render = __bind(this.render, this);
      this.circles = [];
    }

    Map.prototype.render = function() {
      var compiled;
      compiled = _.template(this.template, {
        selector: this.selector
      });
      return this.el.html(compiled);
    };

    Map.prototype.start = function() {
      if (!this.map) {
        this.createSky();
      }
      if (this.data) {
        return this.plotObjects();
      }
    };

    Map.prototype.createSky = function() {
      this.map = L.map("sky-" + this.index, Map.mapOptions).setView([0, 180], 6);
      this.layer = L.tileLayer('/tiles/#{zoom}/#{tilename}.jpg', {
        maxZoom: 7
      });
      this.layer.getTileUrl = function(tilePoint) {
        var convertTileUrl, url, zoom;
        zoom = this._getZoomForUrl();
        convertTileUrl = function(x, y, s, zoom) {
          var d, e, f, g, pixels;
          pixels = Math.pow(2, zoom);
          d = (x + pixels) % pixels;
          e = (y + pixels) % pixels;
          f = "t";
          g = 0;
          while (g < zoom) {
            pixels = pixels / 2;
            if (e < pixels) {
              if (d < pixels) {
                f += "q";
              } else {
                f += "r";
                d -= pixels;
              }
            } else {
              if (d < pixels) {
                f += "t";
                e -= pixels;
              } else {
                f += "s";
                d -= pixels;
                e -= pixels;
              }
            }
            g++;
          }
          return {
            x: x,
            y: y,
            src: f,
            s: s
          };
        };
        url = convertTileUrl(tilePoint.x, tilePoint.y, 1, zoom);
        return "/tiles/" + zoom + "/" + url.src + ".jpg";
      };
      return this.layer.addTo(this.map);
    };

    Map.prototype.plotObject = function(subject, options) {
      var circle, coords, icon, subject_viewer,
        _this = this;
      coords = [subject.dec, subject.ra];
      options = icon = new L.icon({
        iconSize: [25, 41],
        iconAnchor: [13, 41]
      });
      circle = new L.marker(coords, options);
      circle.zooniverse_id = subject.zooniverse_id;
      circle.addTo(this.map);
      subject_viewer = new SubjectViewer;
      subject_viewer.receiveData([subject]);
      subject_viewer.render();
      circle.bindPopup(subject_viewer.el.get(0).outerHTML, {
        maxWidth: 460
      });
      circle.on('click', function() {
        return _this.selectSubject(circle);
      });
      return this.circles.push(circle);
    };

    Map.prototype.plotObjects = function() {
      var latlng, marker, subject, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.circles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        marker = _ref[_i];
        this.map.removeLayer(marker);
      }
      this.circles = new Array;
      this.filterData();
      _ref1 = this.filteredData;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        subject = _ref1[_j];
        this.plotObject(subject);
      }
      latlng = new L.LatLng(this.data[0].dec, this.data[0].ra);
      return this.map.panTo(latlng);
    };

    Map.prototype.selected = function(itemId) {
      var c, circle, item, latlng;
      item = _.find(this.data, function(subject) {
        return subject.zooniverse_id = itemId;
      });
      latlng = new L.LatLng(item.dec, item.ra);
      circle = ((function() {
        var _i, _len, _ref, _results;
        _ref = this.circles;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if (c.zooniverse_id === itemId) {
            _results.push(c);
          }
        }
        return _results;
      }).call(this))[0];
      return this.selectSubject(circle);
    };

    Map.prototype.selectSubject = function(circle) {
      if (this.selected_subject != null) {
        this.selected_subject.setIcon(this.default_icon);
      }
      this.selected_subject = circle;
      circle.openPopup();
      return circle.setIcon(this.selected_icon);
    };

    return Map;

  })(BaseTool);

  if (typeof require === 'function' && typeof module === 'object' && typeof exports === 'object') {
    module.exports = Map;
  } else {
    window.Ubret['Map'] = Map;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var BaseTool, Scatterplot,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  BaseTool = window.Ubret.BaseTool || require('./base_tool');

  Scatterplot = (function(_super) {

    __extends(Scatterplot, _super);

    Scatterplot.prototype.template = "<div id=\"<%- selector %>\">\n  <svg></svg>\n</div>";

    Scatterplot.prototype.tooltip = "<div class=\"tooltip\">\n  <ul>\n    <li><label><%- xAxis %>:</label><span><%- xAxisVal %></span></li>\n    <li><label><%- yAxis %>:</label><span><%- yAxisVal %></span></li>\n  </ul>\n</div>";

    function Scatterplot() {
      this.start = __bind(this.start, this);

      this.setYVar = __bind(this.setYVar, this);

      this.setXVar = __bind(this.setXVar, this);

      this.calculateTicks = __bind(this.calculateTicks, this);

      this.drawPoints = __bind(this.drawPoints, this);

      this.drawAxes = __bind(this.drawAxes, this);

      this.createGraph = __bind(this.createGraph, this);

      this.dataToCoordinates = __bind(this.dataToCoordinates, this);

      this.select = __bind(this.select, this);

      this.removeTooltip = __bind(this.removeTooltip, this);

      this.displayTooltip = __bind(this.displayTooltip, this);

      var compiled;
      Scatterplot.__super__.constructor.apply(this, arguments);
      compiled = _.template(this.template, {
        selector: this.selector
      });
      this.el.html(compiled);
      this.height = this.el.height() || this.height;
      this.width = this.el.width() || this.width;
      this.margin = this.margin || {
        top: 17,
        right: 40,
        bottom: 55,
        left: 75
      };
      this.color = this.color || 'teal';
      this.selectionColor = this.selectionColor || 'orange';
      this.xFormat = this.xFormat || d3.format(',.02f');
      this.yFormat = this.yFormat || d3.format(',.02f');
    }

    Scatterplot.prototype.displayTooltip = function(d, i) {
      var left, tooltip, top, xAxis, xAxisVal, yAxis, yAxisVal;
      xAxis = this.prettyKey(this.xAxisKey);
      yAxis = this.prettyKey(this.yAxisKey);
      xAxisVal = this.xFormat(d.x);
      yAxisVal = this.yFormat(d.y);
      top = d3.event.pageY - 50;
      left = d3.event.pageX + 10;
      tooltip = _.template(this.tooltip, {
        xAxis: xAxis,
        yAxis: yAxis,
        xAxisVal: xAxisVal,
        yAxisVal: yAxisVal
      });
      this.el.append(tooltip);
      return this.el.find('.tooltip').offset({
        top: top,
        left: left
      });
    };

    Scatterplot.prototype.removeTooltip = function(d, i) {
      return this.el.find('.tooltip').remove();
    };

    Scatterplot.prototype.select = function(itemId) {
      return _.indexOf(this.filteredData(itemId));
    };

    Scatterplot.prototype.dataToCoordinates = function(d) {
      var coordinate;
      coordinate = {
        x: d[this.xAxisKey],
        y: d[this.yAxisKey],
        classification: d['classification']
      };
      if ((this.selectedData != null) && __indexOf.call(this.selectedData, d) >= 0) {
        coordinate['color'] = this.selectionColor;
      } else {
        coordinate['color'] = this.color;
      }
      return coordinate;
    };

    Scatterplot.prototype.createGraph = function() {
      var graphData;
      if ((typeof this.xAxisKey === 'undefined') && (typeof this.yAxixKey === 'undefined')) {
        return;
      }
      this.el.find('svg').empty();
      this.graphWidth = this.width - this.margin.left - this.margin.right;
      this.graphHeight = this.height - this.margin.top - this.margin.bottom;
      this.svg = d3.select("" + this.selector + " svg").attr('width', this.width).attr('height', this.height).append('g').attr('transform', "translate(" + this.margin.left + ", " + this.margin.top + ")");
      graphData = this.drawAxes();
      return this.drawPoints(graphData, this.color);
    };

    Scatterplot.prototype.drawAxes = function() {
      var data, xAxis, xDomain, yAxis, yDomain;
      if (this.data.length !== 0) {
        data = _.map(this.data, this.dataToCoordinates);
        xDomain = this.bufferAxes(d3.extent(data, function(d) {
          return d.x;
        }));
        yDomain = this.bufferAxes(d3.extent(data, function(d) {
          return d.y;
        }));
      } else {
        data = [];
        xDomain = [0, 10];
        yDomain = [0, 10];
      }
      if (typeof this.xAxisKey !== 'undefined') {
        this.x = d3.scale.linear().domain(xDomain).range([0, this.graphWidth]);
        xAxis = d3.svg.axis().scale(this.x).orient('bottom').tickFormat(this.xFormat);
        if (data.length !== 0) {
          xAxis.tickValues(this.calculateTicks(this.x));
        }
        this.svg.append('g').attr('class', 'x axis').attr('transform', "translate(0, " + this.graphHeight + ")").call(xAxis);
        this.svg.append('text').attr('class', 'x label').attr('text-anchor', 'middle').attr('x', this.graphWidth / 2).attr('y', this.graphHeight + 40).text(this.prettyKey(this.xAxisKey));
      }
      if (typeof this.yAxisKey !== 'undefined') {
        this.y = d3.scale.linear().domain(yDomain).range([this.graphHeight, 0]);
        yAxis = d3.svg.axis().scale(this.y).orient('left').tickFormat(this.yFormat);
        if (data.length !== 0) {
          yAxis.tickValues(this.calculateTicks(this.y));
        }
        this.svg.append('g').attr('class', 'y axis').attr('transform', 'translate(0, 0)').call(yAxis);
        this.svg.append('text').attr('class', 'y label').attr('text-anchor', 'middle').attr('y', -60).attr('x', -(this.graphHeight / 2)).attr('transform', "rotate(-90)").text(this.prettyKey(this.yAxisKey));
      }
      return data;
    };

    Scatterplot.prototype.drawPoints = function(data) {
      var point,
        _this = this;
      if (data.length !== 0) {
        point = this.svg.selectAll('.point').data(data).enter().append('g').attr('class', 'point').attr('transform', function(d) {
          if (!(d.x != null) || !(d.y != null)) {

          } else {
            return "translate(" + (_this.x(d.x)) + ", " + (_this.y(d.y)) + ")";
          }
        }).on('mouseover', this.displayTooltip).on('mouseout', this.removeTooltip);
        return point.append('circle').attr('r', 3).attr('id', function(d) {
          return d.x;
        }).attr('fill', function(d) {
          return d.color;
        });
      }
    };

    Scatterplot.prototype.bufferAxes = function(domain) {
      var border, i, _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = domain.length; _i < _len; i = ++_i) {
        border = domain[i];
        if (border > 0) {
          _results.push(border = border - (border * 0.15));
        } else {
          _results.push(border = border + (border * 0.15));
        }
      }
      return _results;
    };

    Scatterplot.prototype.calculateTicks = function(axis) {
      var max, min, numTicks, tick, tickWidth, ticks;
      min = _.first(axis.domain());
      max = _.last(axis.domain());
      ticks = [min, max];
      numTicks = Math.floor(this.graphWidth / 50);
      tickWidth = (max - min) / numTicks;
      tick = min + tickWidth;
      while (tick < max) {
        ticks.push(tick);
        tick = tick + tickWidth;
      }
      return ticks;
    };

    Scatterplot.prototype.setXVar = function(variable) {
      this.xAxisKey = variable;
      return this.createGraph();
    };

    Scatterplot.prototype.setYVar = function(variable) {
      this.yAxisKey = variable;
      return this.createGraph();
    };

    Scatterplot.prototype.start = function() {
      return this.createGraph();
    };

    return Scatterplot;

  })(BaseTool);

  if (typeof require === 'function' && typeof module === 'object' && typeof exports === 'object') {
    module.exports = Scatterplot;
  } else {
    window.Ubret['Scatterplot'] = Scatterplot;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var BaseTool, Spectra,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseTool = window.Ubret.BaseTool || require('./base_tool');

  Spectra = (function(_super) {

    __extends(Spectra, _super);

    Spectra.prototype.name = "Spectra";

    Spectra.prototype.template = "<div id=\"spectra-<%- @index %>\"></div>";

    function Spectra() {
      this.plot = __bind(this.plot, this);

      this.zoom = __bind(this.zoom, this);

      this.render = __bind(this.render, this);
      Spectra.__super__.constructor.apply(this, arguments);
    }

    Spectra.prototype.render = function() {
      var compiled;
      compiled = _.template(this.template, this.index);
      return this.tool_view.html(compiled);
    };

    Spectra.prototype.zoom = function() {
      this.svg.select(".x.axis").call(this.xAxis);
      this.svg.select(".y.axis").call(this.yAxis);
      this.svg.select("path.fluxes").attr("d", this.fluxLine);
      return this.svg.select("path.best-fit").attr("d", this.bestFitLine);
    };

    Spectra.prototype.plot = function() {
      var bestFit, fluxes, height, margin, name, spectralLines, wavelength, wavelengths, width, x, y, _results,
        _this = this;
      wavelengths = this.data[0].wavelengths;
      fluxes = this.data[0].flux;
      bestFit = this.data[0].best_fit;
      spectralLines = this.data[0].spectralLines;
      margin = {
        top: 14,
        right: 10,
        bottom: 14,
        left: 40
      };
      width = 370 - margin.left - margin.right;
      height = 200 - margin.top - margin.bottom;
      x = d3.scale.linear().range([0, width]).domain(d3.extent(wavelengths));
      y = d3.scale.linear().range([0, height]).domain(d3.extent(fluxes));
      x.ticks(8);
      this.xAxis = d3.svg.axis().scale(x).orient("bottom");
      this.yAxis = d3.svg.axis().scale(y).orient("left");
      this.fluxLine = d3.svg.line().x(function(d, i) {
        return x(wavelengths[i]);
      }).y(function(d, i) {
        return y(d);
      });
      this.bestFitLine = d3.svg.line().x(function(d, i) {
        return x(wavelengths[i]);
      }).y(function(d, i) {
        return y(d);
      });
      this.svg = d3.select("#spectra-" + this.index).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', "translate(" + margin.left + ", " + margin.top + ")").call(d3.behavior.zoom().x(x).y(y).scaleExtent([1, 8]).on("zoom", this.zoom));
      this.svg.append("g").attr("class", "x axis").attr("transform", "translate(0, " + height + ")").call(this.xAxis);
      this.svg.append("g").attr("class", "y axis").call(this.yAxis).append("text").attr("transform", "rotate(-90)").attr("y", 6).attr("dy", ".71em").style("text-anchor", "end").text("Flux (1E-17 erg/cm^2/s/Ang)");
      this.svg.append("path").datum(fluxes).attr("class", "line fluxes").attr("d", this.fluxLine);
      this.svg.append("path").datum(bestFit).attr("class", "line best-fit").attr("d", this.bestFitLine);
      _results = [];
      for (name in spectralLines) {
        wavelength = spectralLines[name];
        _results.push(this.svg.append("line").attr("x1", x(wavelength)).attr("x2", x(wavelength)).attr("y1", 0).attr("y2", height).style("stroke", "rgb(255,0,0)").style("stroke-width", 0.5));
      }
      return _results;
    };

    return Spectra;

  })(BaseTool);

  if (typeof require === 'function' && typeof module === 'object' && typeof exports === 'object') {
    module.exports = Spectra;
  } else {
    window.Ubret['Spectra'] = Spectra;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var BaseTool, Statistics,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseTool = window.Ubret.BaseTool || require('./base_tool');

  Statistics = (function(_super) {

    __extends(Statistics, _super);

    function Statistics(opts) {
      this.kurtosis = __bind(this.kurtosis, this);

      this.skew = __bind(this.skew, this);

      this.standardDeviation = __bind(this.standardDeviation, this);

      this.variance = __bind(this.variance, this);

      this.max = __bind(this.max, this);

      this.min = __bind(this.min, this);

      this.mode = __bind(this.mode, this);

      this.median = __bind(this.median, this);

      this.mean = __bind(this.mean, this);

      this.displayStats = __bind(this.displayStats, this);

      this.createStats = __bind(this.createStats, this);

      this.createList = __bind(this.createList, this);

      this.start = __bind(this.start, this);
      Statistics.__super__.constructor.call(this, opts);
      this.displayFormat = opts.format ? d3.format(opts.format) : d3.format(',.03f');
      this.createList();
      this.start();
    }

    Statistics.prototype.start = function() {
      this.createStats();
      return this.displayStats();
    };

    Statistics.prototype.createList = function() {
      return this.ul = d3.select(this.selector).append('ul').attr('class', 'statistics');
    };

    Statistics.prototype.createStats = function() {
      var stat, _i, _len, _ref, _results;
      this.statistics = new Array;
      _ref = ['mean', 'median', 'mode', 'min', 'max', 'variance', 'standardDeviation', 'skew', 'kurtosis'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        stat = _ref[_i];
        _results.push(this.statistics.push([stat, this[stat]()]));
      }
      return _results;
    };

    Statistics.prototype.displayStats = function() {
      var li,
        _this = this;
      this.ul.selectAll('li').remove();
      return li = this.ul.selectAll('li').data(this.statistics).enter().append('li').attr('data-stat', function(d) {
        return d[0];
      }).text(function(d) {
        return "" + (_this.formatKey(d[0])) + ": " + (_this.displayFormat(d[1]));
      });
    };

    Statistics.prototype.mean = function() {
      var count, sum,
        _this = this;
      count = this.dimensions.id.groupAll().reduceCount().value();
      sum = this.dimensions.id.groupAll().reduce((function(p, v) {
        return p + v[_this.selectedKey];
      }), (function(p, v) {
        return p - v[_this.selectedKey];
      }), (function(p, v) {
        return 0;
      })).value();
      return sum / count;
    };

    Statistics.prototype.median = function() {
      var count, median, midPoint;
      count = this.dimensions.id.groupAll().reduceCount().value();
      midPoint = count / 2;
      if (midPoint % 1) {
        median = (this.dimensions[this.selectedKey].top(Math.floor(midPoint)) + this.dimensions[this.selectedKey].top(Math.ceil(midPoint))) / 2;
      } else {
        median = this.dimensions[this.selectedKey].top(midPoint);
      }
      return _.last(median)[this.selectedKey];
    };

    Statistics.prototype.mode = function() {
      var mode;
      mode = this.dimensions[this.selectedKey].group().reduceCount().top(1);
      return mode[0].key;
    };

    Statistics.prototype.min = function() {
      return this.dimensions[this.selectedKey].bottom(1)[0][this.selectedKey];
    };

    Statistics.prototype.max = function() {
      return this.dimensions[this.selectedKey].top(1)[0][this.selectedKey];
    };

    Statistics.prototype.variance = function() {
      var count, mean, variance, varianceFormulaAdd, varianceFormulaRemove,
        _this = this;
      count = this.dimensions.id.groupAll().reduceCount().value();
      mean = this.mean();
      varianceFormulaAdd = function(p, v) {
        return p + Math.pow(Math.abs(v[_this.selectedKey] - mean), 2);
      };
      varianceFormulaRemove = function(p, v) {
        return p - Math.pow(Math.abs(v[_this.selectedKey] - mean), 2);
      };
      variance = this.dimensions.id.groupAll().reduce(varianceFormulaAdd, varianceFormulaRemove, function(p, v) {
        return 0;
      }).value();
      return variance / count;
    };

    Statistics.prototype.standardDeviation = function() {
      return Math.sqrt(this.variance());
    };

    Statistics.prototype.skew = function() {
      var count, denom, mean, reduceAdd, reduceRemove, standardDeviation, sum,
        _this = this;
      mean = this.mean();
      standardDeviation = this.standardDeviation();
      count = this.dimensions.id.groupAll().reduceCount().value();
      reduceAdd = function(p, v) {
        return p + Math.pow(v[_this.selectedKey] - mean, 3);
      };
      reduceRemove = function(p, v) {
        return p - Math.pow(v[_this.selectedKey] - mean, 3);
      };
      sum = this.dimensions.id.groupAll().reduce(reduceAdd, reduceRemove, function(p, v) {
        return 0;
      }).value();
      denom = count * Math.pow(standardDeviation, 3);
      return sum / denom;
    };

    Statistics.prototype.kurtosis = function() {
      var count, denom, kurtosis, mean, reduceAdd, reduceRemove, standardDeviation, sum,
        _this = this;
      mean = this.mean();
      standardDeviation = this.standardDeviation();
      count = this.dimensions.id.groupAll().reduceCount().value();
      reduceAdd = function(p, v) {
        return p + Math.pow(v[_this.selectedKey] - mean, 4);
      };
      reduceRemove = function(p, v) {
        return p - Math.pow(v[_this.selectedKey] - mean, 4);
      };
      sum = this.dimensions.id.groupAll().reduce(reduceAdd, reduceRemove, function(p, v) {
        return 0;
      }).value();
      denom = count * Math.pow(standardDeviation, 4);
      return kurtosis = sum / denom;
    };

    return Statistics;

  })(BaseTool);

  if (typeof require === 'function' && typeof module === 'object' && typeof exports === 'object') {
    module.exports = Statistics;
  } else {
    window.Ubret['Statistics'] = Statistics;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var BaseTool, SubjectViewer,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseTool = window.Ubret.BaseTool || require('./base_tool');

  SubjectViewer = (function(_super) {

    __extends(SubjectViewer, _super);

    SubjectViewer.prototype.template = "<% if(subject.image) { %>\n  <img src=\"<%- subject.image %>\" />\n<% } %>\n\n<ul>\n  <% for(i = 0; i < keys.length; i++) { %>\n    <li>\n      <%- keys[i] %>: <%- subject[keys[i]] %>\n    </li>\n  <% } %>\n</ul>";

    function SubjectViewer(opts) {
      this.nextSubject = __bind(this.nextSubject, this);

      this.prevSubject = __bind(this.prevSubject, this);

      this.render = __bind(this.render, this);

      this.start = __bind(this.start, this);
      SubjectViewer.__super__.constructor.apply(this, arguments);
      this.count = 0;
      this.start();
    }

    SubjectViewer.prototype.start = function() {
      var datum, i, _i, _len, _ref;
      if (this.selectedElement) {
        _ref = this.data;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          datum = _ref[i];
          if (this.selectedElement === datum.id) {
            this.count = i;
          }
        }
      }
      return this.render();
    };

    SubjectViewer.prototype.render = function() {
      var compiled;
      compiled = _.template(this.template, {
        subject: this.data[this.count],
        keys: this.keys
      });
      return this.el.html(compiled);
    };

    SubjectViewer.prototype.prevSubject = function() {
      this.count -= 1;
      if (this.count < 0) {
        this.count = this.data.length - 1;
      }
      return this.selectElementCb(this.data[this.count].id);
    };

    SubjectViewer.prototype.nextSubject = function() {
      this.count += 1;
      if (this.count >= this.data.length) {
        this.count = 0;
      }
      return this.selectElementCb(this.data[this.count].id);
    };

    return SubjectViewer;

  })(BaseTool);

  if (typeof require === 'function' && typeof module === 'object' && typeof exports === 'object') {
    module.exports = SubjectViewer;
  } else {
    window.Ubret['SubjectViewer'] = SubjectViewer;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var BaseTool, Table,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseTool = window.Ubret.BaseTool || require('./base_tool');

  Table = (function(_super) {

    __extends(Table, _super);

    function Table(opts) {
      this.arrow = __bind(this.arrow, this);

      this.selection = __bind(this.selection, this);

      this.changeData = __bind(this.changeData, this);

      this.highlightRows = __bind(this.highlightRows, this);

      this.toArray = __bind(this.toArray, this);

      this.createRows = __bind(this.createRows, this);

      this.createHeader = __bind(this.createHeader, this);

      this.createTable = __bind(this.createTable, this);

      this.start = __bind(this.start, this);
      Table.__super__.constructor.call(this, opts);
      this.sortOrder = 'top';
      this.createTable();
      this.start();
    }

    Table.prototype.start = function() {
      this.createHeader();
      return this.createRows();
    };

    Table.prototype.createTable = function() {
      var table;
      table = d3.select(this.selector).append('table');
      this.thead = table.append('thead');
      return this.tbody = table.append('tbody');
    };

    Table.prototype.createHeader = function() {
      var _this = this;
      this.thead.selectAll('th').remove();
      return this.thead.selectAll("th").data(this.keys).enter().append("th").on('click', function(d, i) {
        return _this.selectKey(d);
      }).attr('data-key', function(d) {
        return d;
      }).text(function(d) {
        return "" + (_this.formatKey(d)) + " " + (d === _this.selectedKey ? _this.arrow() : void 0);
      });
    };

    Table.prototype.createRows = function() {
      var tr,
        _this = this;
      this.tbody.selectAll('tr').remove();
      tr = this.tbody.selectAll('tr').data(this.dimensions[this.selectedKey][this.sortOrder](Infinity)).enter().append('tr').attr('data-id', function(d) {
        return d.id;
      }).on('click', this.selection);
      tr.selectAll('td').data(function(d) {
        return _this.toArray(d);
      }).enter().append('td').text(function(d) {
        return d;
      });
      if (this.selectedElements) {
        return this.highlightRows();
      }
    };

    Table.prototype.toArray = function(data) {
      var key, ret, _i, _len, _ref;
      ret = new Array;
      _ref = this.keys;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        ret.push(data[key]);
      }
      return ret;
    };

    Table.prototype.highlightRows = function() {
      var id, _i, _len, _ref, _results;
      _ref = this.selectedElements;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        _results.push(this.tbody.select("[data-id=" + id + "]").attr('class', 'selected'));
      }
      return _results;
    };

    Table.prototype.changeData = function(data) {
      this.data = data;
      return this.start();
    };

    Table.prototype.selectKey = function(key) {
      if (key === this.selectedKey && this.sortOrder === 'top') {
        this.sortOrder = 'bottom';
      } else {
        this.sortOrder = 'top';
      }
      return Table.__super__.selectKey.call(this, key);
    };

    Table.prototype.selection = function(d, i) {
      var ids, index;
      ids = this.selectedElements;
      if (d3.event.shiftKey) {
        index = _.indexOf(this.selectedElements, d.id);
        if (index === -1) {
          ids.push(d.id);
        } else {
          ids = _.without(ids, d.id);
        }
      } else {
        ids = [d.id];
      }
      return this.selectElements(ids);
    };

    Table.prototype.arrow = function() {
      if (this.sortOrder === 'top') {
        return '▲';
      } else {
        return '▼';
      }
    };

    return Table;

  })(BaseTool);

  if (typeof require === 'function' && typeof module === 'object' && typeof exports === 'object') {
    module.exports = Table;
  } else {
    window.Ubret['Table'] = Table;
  }

}).call(this);
