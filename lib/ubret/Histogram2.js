// Generated by CoffeeScript 1.4.0
(function() {
  var Graph, Histogram2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Graph = window.Ubret.Graph || require('./Graph');

  Histogram2 = (function(_super) {

    __extends(Histogram2, _super);

    Histogram2.prototype.axes = 1;

    Histogram2.prototype.template = "<div class=\"histogram\">\n  <div id=\"<%- selector %>\">\n    <svg></svg>\n  </div>\n</div>";

    function Histogram2(opts) {
      this.brushend = __bind(this.brushend, this);

      this.drawBrush = __bind(this.drawBrush, this);

      this.drawData = __bind(this.drawData, this);

      this.setupData = __bind(this.setupData, this);
      Histogram2.__super__.constructor.call(this, opts);
      this.bins = opts.bins ? opts.bins : 2 * Math.floor(Math.log(this.count) / Math.log(2) + 1);
      this.axis2 = opts.yLabel || 'Count';
    }

    Histogram2.prototype.setupData = function() {
      var data, group, min, top,
        _this = this;
      top = this.dimensions[this.axis1].top(Infinity);
      data = _.map(top, function(d) {
        return d[_this.axis1];
      });
      this.xDomain = d3.extent(data);
      this.binSize = (Math.ceil(this.xDomain[1]) - Math.floor(this.xDomain[0])) / this.bins;
      min = this.xDomain[0];
      group = this.dimensions[this.axis1].group(function(d) {
        return Math.floor((d - min) / _this.binSize);
      });
      this.data = group.top(Infinity);
      return this.yDomain = [0, this.data[0].value];
    };

    Histogram2.prototype.drawData = function() {
      var _this = this;
      return this.bars = this.svg.append('g').selectAll('.bar').data(this.data).enter().append('rect').attr('class', 'bar').attr('x', function(d) {
        return _this.x(d.key * _this.binSize);
      }).attr('width', this.x(this.binSize)).attr('y', function(d) {
        return _this.y(d.value);
      }).attr('height', function(d) {
        return _this.graphHeight - _this.y(d.value);
      }).attr('fill', '#0071E5').attr('stroke', '#FAFAFA');
    };

    Histogram2.prototype.drawBrush = function() {
      return this.brush = this.svg.append('g').attr('class', 'brush').attr('width', this.graphWidth).attr('height', this.graphHeight).call(d3.svg.brush().x(this.x).on('brushend', this.brushend)).selectAll('rect').attr('height', this.graphHeight).attr('opacity', 0.5).attr('fill', '#CD3E20');
    };

    Histogram2.prototype.brushend = function() {
      var data, top,
        _this = this;
      this.dimensions[this.axis1].filter(d3.event.target.extent());
      top = this.dimensions[this.axis1].top(Infinity);
      data = _.map(top, function(d) {
        return d[_this.axis1];
      });
      console.log("min = ", Math.min.apply(Math, data));
      console.log("max = ", Math.max.apply(Math, data));
      return console.log("len = ", data.length);
    };

    return Histogram2;

  })(Graph);

  if (typeof require === 'function' && typeof module === 'object' && typeof exports === 'object') {
    module.exports = Histogram2;
  } else {
    window.Ubret['Histogram2'] = Histogram2;
  }

}).call(this);
